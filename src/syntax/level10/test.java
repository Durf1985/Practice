package syntax.level10;

public class test {
    public static void main(String[] args) {
        Object o = 123;  //o хранит Integer
        /*При присваивании объекту значения int происходит расширение типов, т.е. расширение это
          когда объект наследник присваевается объекту родителю*/
        Float s2 = (Float) o;
        /*здесь у нас происходит сужение при присваивании, т.е. нужно проверить, соответствует ли тип в переменной "о"
        типу "s2", т.е. при сужении или расширении ссылочных типов не происходит никаких изменений объекта, в отличии
        от примитивов, где при сужении можно потерять часть значений. В данном случае мы можем в ручную проверить
        какой тип хранится в объекте о при присваивании его другому объекту, т.е. операция присваивания является сужающей
         или расширяющей, т.е. все сводится к простому как коровье мычание тезису нельзя выполнить присваивание
          Float = Integer,Double и т.д., самая простая аналогия - нельзя в ArrayList<Integer> = new ArrayList<Cat>(),
          запихнуть кота операция сужения/присваивания не будет проведена*/
        System.out.println(s2);

    }
    // вообще расширение и сужение типов смотрится не по тому, каким функционалом обладает тот или иной предок или
    // потомок, а смотрится какое количество типов наследников может содержать в себе
    // родитель. Т.е если у вас Animal может содержать и кота и собаку и носорога, то носорог не может хранить в себе
    // ни кота, ни собаку. И без разницы, что у Animal всего 2 метода можно вызвать, а у носорога 22
    // поэтому когда присваивают более функциональный класс своему менее функциональному классу родителю,
    // то говорят расширение, а не сужение, потому что отсчет идет не от функциональности
}
